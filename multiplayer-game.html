<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer 3D Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      pointer-events: none;
    }

    #name-input-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }

    #name-input-screen h1 {
      color: white;
      font-size: 56px;
      margin-bottom: 20px;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
    }

    #name-input-screen p {
      color: #aaa;
      font-size: 18px;
      margin-bottom: 40px;
    }

    #player-name-input {
      padding: 20px 40px;
      font-size: 24px;
      border: 3px solid #667eea;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      min-width: 300px;
      margin-bottom: 30px;
      pointer-events: all;
    }

    #player-name-input::placeholder {
      color: #777;
    }

    #name-submit-btn {
      padding: 20px 60px;
      font-size: 28px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    #name-submit-btn:hover {
      transform: scale(1.05) translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    #character-selection {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    #character-selection h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #characters-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      max-width: 90vw;
      max-height: 80vh;
      width: clamp(600px, 80vw, 1400px);
      padding: 0 10px;
      overflow-y: auto;
    }

    .character-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid #667eea;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    .character-btn:hover {
      transform: scale(1.05);
      border-color: #764ba2;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
    }

    .character-preview {
      width: 100%;
      aspect-ratio: 1;
      max-width: 200px;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
    }

    .character-name {
      font-size: clamp(14px, 3vw, 20px);
      font-weight: bold;
      color: white;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .character-stats {
      width: 100%;
      font-size: 11px;
      color: #ccc;
      text-align: left;
    }

    .stat-row {
      display: flex;
      align-items: center;
      margin: 4px 0;
      gap: 5px;
    }

    .stat-label {
      min-width: 60px;
      font-size: 10px;
      color: #aaa;
    }

    .stat-bar-container {
      flex: 1;
      height: 8px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      overflow: hidden;
    }

    .stat-bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }

    .stat-bar.health { background: linear-gradient(90deg, #ff4444, #ff8888); }
    .stat-bar.damage { background: linear-gradient(90deg, #ff8800, #ffaa44); }
    .stat-bar.speed { background: linear-gradient(90deg, #00ff88, #44ffaa); }
    .stat-bar.firerate { background: linear-gradient(90deg, #4488ff, #88bbff); }

    @media (max-width: 768px) {
      #characters-list {
        grid-template-columns: repeat(2, 1fr);
        width: 95vw;
      }
    }

    @media (max-width: 480px) {
      #characters-list {
        grid-template-columns: repeat(2, minmax(120px, 1fr));
        width: 95vw;
      }
    }

    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    #player-list {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      min-width: 200px;
      pointer-events: none;
    }

    #player-list h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #44ff88;
    }

    .player-item {
      padding: 5px 0;
      font-size: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    #controls-help {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      font-size: 12px;
      pointer-events: none;
    }

    #crosshair {
      position: fixed;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 1000;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
      top: 0;
    }

    #crosshair::after {
      width: 20px;
      height: 2px;
      left: 0;
      top: 9px;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 3000;
    }
  </style>
</head>
<body>
  
  <div id="loading">Loading game...</div>

  
  <div id="ui">
    
    <div id="hud">
      <div id="health" style="font-size: 20px; font-weight: bold; color: #00ff00;">HP: 100</div>
      <div id="character-name" style="margin-top: 5px;">Character: None</div>
      <div id="player-count" style="margin-top: 10px; color: #44ff88; font-weight: bold;">Players Online: 1</div>
    </div>

    
    <div id="player-list">
      <h3>Players Online</h3>
      <div id="players"></div>
    </div>

    
    <div id="controls-help">
      <div><strong>Controls:</strong></div>
      <div>WASD - Move</div>
      <div>SPACE - Jump</div>
      <div>Mouse - Aim</div>
      <div>Left Click - Shoot</div>
      <div>E - Toggle Build Mode</div>
      <div>E (2nd) - Place Block</div>
      <div>ESC - Cancel Build</div>
    </div>

    
    <div id="crosshair"></div>
  </div>

  
  
  <div id="name-input-screen">
    <h1>ðŸŽ® 3D MULTIPLAYER ARENA ðŸŽ®</h1>
    <p>Enter your name to track your stats across games</p>
    <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="20" />
    <button id="name-submit-btn">START GAME</button>
  </div>

  
  <div id="character-selection">
    <h1>Select Your Character</h1>
    <div id="characters-list">
      <button class="character-btn" data-character="soldier">
        <canvas class="character-preview" data-character="soldier"></canvas>
        <span class="character-name">PEPETOSHI</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 92%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 83%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 70%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 50%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="robot">
        <canvas class="character-preview" data-character="robot"></canvas>
        <span class="character-name">ACOUSTIC PINKY</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 77%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 67%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 75%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 67%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="ninja">
        <canvas class="character-preview" data-character="ninja"></canvas>
        <span class="character-name">BENJI</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 62%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 56%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 100%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 100%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="wizard">
        <canvas class="character-preview" data-character="wizard"></canvas>
        <span class="character-name">BASED CLOWN</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 69%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 100%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 65%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 40%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="knight">
        <canvas class="character-preview" data-character="knight"></canvas>
        <span class="character-name">SIR WIGGLES</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 100%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 56%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 60%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 44%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="archer">
        <canvas class="character-preview" data-character="archer"></canvas>
        <span class="character-name">OC CAM</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 54%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 44%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 80%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 100%"></div></div></div>
        </div>
      </button>
      <button class="character-btn" data-character="mech">
        <canvas class="character-preview" data-character="mech"></canvas>
        <span class="character-name">CHEEKY</span>
        <div class="character-stats">
          <div class="stat-row"><span class="stat-label">Health:</span><div class="stat-bar-container"><div class="stat-bar health" style="width: 85%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Damage:</span><div class="stat-bar-container"><div class="stat-bar damage" style="width: 78%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Speed:</span><div class="stat-bar-container"><div class="stat-bar speed" style="width: 75%"></div></div></div>
          <div class="stat-row"><span class="stat-label">Fire Rate:</span><div class="stat-bar-container"><div class="stat-bar firerate" style="width: 62%"></div></div></div>
        </div>
      </button>
    </div>
  </div>

  
  <script src="/content/39df128491c33911ebff0afd1130c8b534311ed5258bbbd29e90ab65e0bf9b2bi0"></script>

  
  <script type="module">
    
    import * as THREE from '/content/a4a6f99205628bdc3ca2143a4e380f7ebc576b4414c16dffdb34be28337ffe83i0';

    
    
    window.THREE = Object.assign({}, THREE);

    
    Object.getOwnPropertyNames(THREE).forEach(key => {
      if (!(key in window.THREE)) {
        try {
          window.THREE[key] = THREE[key];
        } catch (e) {
          
        }
      }
    });

    
    await import('/content/00ae91a4f7f4f6fa98c1deb0f57359079f7b5299094378ff15fa1c7f4366db3ci0');
    await import('/content/d9f5134fdd4a1ae7a5c3fe1b42876cc4e18f4ce404a39394f9157679c60e965fi0');
    await import('/content/183616632d0baeeaf8bc7bbda1766ea1fb19e76f63fdf136456e075bf19ed08di0');


    await new Promise(resolve => {
      if (window.CANNON) {
        resolve();
      } else {
        const checkCannon = setInterval(() => {
          if (window.CANNON) {
            clearInterval(checkCannon);
            resolve();
          }
        }, 100);
      }
    });


    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }

      random() {
        const x = Math.sin(this.seed++) * 10000;
        return x - Math.floor(x);
      }
    }

    const TERRAIN_SEED = 12345;
    const seededRandom = new SeededRandom(TERRAIN_SEED);


    let scene, camera, renderer;
    let world; 
    let myPlayer = null;
    let myPlayerBody = null; 
    let mySocketId = null; 
    let myHealth = 100;
    let players = new Map();
    let blocks = new Map();
    let bullets = [];

    
    let keys = {};
    let selectedCharacter = null;
    let isCharacterSelected = false;
    let connected = false;
    let playerName = null; 
    let playerStats = { kills: 0, deaths: 0, score: 0 }; 

    
    let cameraYaw = 0; 
    let cameraPitch = 0.3; 
    const cameraDistance = 5; 
    const cameraHeight = 2; 
    let mouseX = window.innerWidth / 2; 
    let mouseY = window.innerHeight / 2; 
    let lastMouseX = window.innerWidth / 2;
    let lastMouseY = window.innerHeight / 2;
    let isAtEdge = { left: false, right: false, top: false, bottom: false }; 

    
    const CHARACTER_CONFIG = {
      soldier: {
        model: '/content/5c6a56627d1750fcb586605734fa4c3de7170e74a2b98d5692f46c5cb7c4edcci0',
        health: 120, 
        damage: 15, 
        fireRate: 800, 
        bulletSpeed: 18, 
        moveSpeed: 0.14, 
        color: 0x556b2f
      },
      robot: {
        model: '/content/c781f4d5a796472b34cc8cad584963a3b293c018d737ef281844a7a326f62cdfi0',
        health: 100, 
        damage: 12, 
        fireRate: 600, 
        bulletSpeed: 20, 
        moveSpeed: 0.15, 
        color: 0x808080
      },
      ninja: {
        model: '/content/285f271618ce9c7280e0d165bdfffb4a6b4111ddf638a363d483a42264e98cebi0',
        health: 80, 
        damage: 10, 
        fireRate: 400, 
        bulletSpeed: 25, 
        moveSpeed: 0.20, 
        color: 0x2f4f4f
      },
      wizard: {
        model: '/content/1871e1f6f357081de637d08c6a500f4d1f9658b99a0041465afbcbd97247eb20i0',
        health: 90, 
        damage: 18, 
        fireRate: 1000, 
        bulletSpeed: 15, 
        moveSpeed: 0.13, 
        color: 0x4b0082
      },
      knight: {
        model: '/content/a056eee27b584653d7a974ba1eb3951a2b11f6368207fbcb5f6fd32df6699677i0',
        health: 130, 
        damage: 10, 
        fireRate: 900, 
        bulletSpeed: 16, 
        moveSpeed: 0.12, 
        color: 0xc0c0c0
      },
      archer: {
        model: '/content/2e669b2290d6d7c18df10c98d6a4b85dc8cb42fa3387eff4d7bba5554cf966d6i0',
        health: 70, 
        damage: 8, 
        fireRate: 300, 
        bulletSpeed: 30, 
        moveSpeed: 0.16, 
        color: 0x228b22
      },
      mech: {
        model: '/content/7cadbab459a8baa58404292784680d6d8726ac97fa4c24ff4426042bca33ae3bi0',
        health: 110, 
        damage: 14, 
        fireRate: 650, 
        bulletSpeed: 22, 
        moveSpeed: 0.15, 
        color: 0x4a4a4a
      }
    };

    
    let gltfLoader = null;
    let loadedModels = new Map(); 

    
    const moveSpeed = 0.15;
    const jumpPower = 0.4;
    let velocity = { x: 0, y: 0, z: 0 };
    let isGrounded = false;

    
    let lastShotTime = 0;
    let recentShots = []; 

    
    let buildMode = false; 
    let ghostBlock = null; 
    let raycaster = new THREE.Raycaster(); 
    let mouseNDC = new THREE.Vector2(0, 0); 

    
    let lastPositionSent = { x: 0, y: 0, z: 0 };
    let lastNetworkUpdate = 0;
    const NETWORK_UPDATE_INTERVAL = 50; 

    
    let messageRequestId = 0;
    const pendingRequests = new Map();

    
    const CHARACTER_COLORS = {
      soldier: 0x00ff00,
      robot: 0x888888,
      ninja: 0x000000,
      wizard: 0x9900ff,
      knight: 0xffaa00,
      archer: 0x00ffff,
      mech: 0x4a4a4a
    };

    
    const CHARACTER_NAMES = {
      soldier: 'PepeToshi',
      robot: 'Acoustic Pinky',
      ninja: 'Benji',
      wizard: 'Based Clown',
      knight: 'Sir Wiggles',
      archer: 'OC Cam',
      mech: 'Cheeky'
    };

    
    function sendToExtension(type, data = {}) {
      return new Promise((resolve, reject) => {
        const requestId = ++messageRequestId;
        pendingRequests.set(requestId, { resolve, reject });

        const message = { type: type, requestId: requestId, ...data };

        
        window.postMessage(message, '*');
        if (window.parent && window.parent !== window) {
          window.parent.postMessage(message, '*');
        }
        if (window.top && window.top !== window) {
          window.top.postMessage(message, '*');
        }

        
        setTimeout(() => {
          if (pendingRequests.has(requestId)) {
            pendingRequests.delete(requestId);
            reject(new Error('Request timeout'));
          }
        }, 10000);
      });
    }

    
    window.addEventListener('message', (event) => {
      const message = event.data;
      if (!message || !message.type) return;

      
      if (message.type.startsWith('GAME_')) {
        console.log('[Game] Received message:', message.type, message);
      }

      
      if (message.requestId && pendingRequests.has(message.requestId)) {
        const { resolve } = pendingRequests.get(message.requestId);
        pendingRequests.delete(message.requestId);
        resolve(message);
        return;
      }

      
      switch (message.type) {
        case 'GAME_CONNECTED':
          connected = true;
          break;

        case 'yourSocketId':
          mySocketId = message.id || message.data;
          break;

        case 'GAME_DISCONNECTED':
          connected = false;
          break;

        case 'GAME_STATE':
          updateGameState(message.state);
          break;

        case 'GAME_PLAYER_JOINED':
          addPlayer(message.id, message.character);
          updatePlayerList();
          break;

        case 'GAME_PLAYER_LEFT':
          removePlayer(message.id);
          updatePlayerList();
          break;

        case 'GAME_PLAYER_MOVED':
          updatePlayerPosition(message.id, message.position, message.rotation);
          break;

        case 'GAME_BULLET_FIRED':
          createBullet(message.bullet);
          break;

        case 'GAME_BLOCK_PLACED':
          console.log('[Game] Received GAME_BLOCK_PLACED:', message.block);
          
          if (message.block && !blocks.has(message.block.id)) {
            placeBlock(message.block);
          } else {
            console.log('[Game] Block already exists, skipping duplicate placement');
          }
          break;

        case 'GAME_BLOCK_DESTROYED':
          console.log('[Game] Received GAME_BLOCK_DESTROYED:', message.id);
          destroyBlock(message.id);
          break;
      }
    });

    
    function init() {

      
      const nameInput = document.getElementById('player-name-input');
      const nameSubmitBtn = document.getElementById('name-submit-btn');

      
      const submitName = () => {
        const name = nameInput.value.trim();
        if (name.length > 0) {
          playerName = name;
          
          document.getElementById('name-input-screen').style.display = 'none';
          document.getElementById('character-selection').style.display = 'flex';

          
          setTimeout(() => loadCharacterPreviews(), 100);
        } else {
          alert('Please enter a name!');
        }
      };

      nameSubmitBtn.addEventListener('click', submitName);
      nameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitName();
      });

      
      document.querySelectorAll('.character-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const character = btn.getAttribute('data-character');
          selectCharacter(character);
        });
      });

      
      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0); 
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      
      const dracoLoader = new window.THREE.DRACOLoader();
      dracoLoader.setDecoderPath('/content/');

      gltfLoader = new window.THREE.GLTFLoader();
      gltfLoader.setDRACOLoader(dracoLoader);

      
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);

      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      
      const crosshair = document.getElementById('crosshair');
      if (crosshair) {
        crosshair.style.left = (window.innerWidth / 2) + 'px';
        crosshair.style.top = (window.innerHeight / 2) + 'px';
      }

      
      let mouseMoveCount = 0;

      document.addEventListener('mousemove', (e) => {
        if (!myPlayer) return;

        
        mouseX = e.clientX;
        mouseY = e.clientY;

        
        const deltaX = mouseX - lastMouseX;
        const deltaY = mouseY - lastMouseY;

        
        lastMouseX = mouseX;
        lastMouseY = mouseY;

        
        const sensitivity = 0.003;

        
        cameraYaw -= deltaX * sensitivity;
        cameraPitch += deltaY * sensitivity; 

        

        
        const edgeThreshold = 100; 
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        isAtEdge.left = mouseX < edgeThreshold;
        isAtEdge.right = mouseX > screenWidth - edgeThreshold;
        isAtEdge.top = mouseY < edgeThreshold;
        isAtEdge.bottom = mouseY > screenHeight - edgeThreshold;

        
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          crosshair.style.left = mouseX + 'px';
          crosshair.style.top = mouseY + 'px';
        }

        
        mouseNDC.x = (mouseX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(mouseY / window.innerHeight) * 2 + 1;

        
        mouseMoveCount++;
        if (mouseMoveCount % 100 === 0) {
          console.log('[Game] Mouse moving - Yaw:', cameraYaw.toFixed(2), 'Pitch:', cameraPitch.toFixed(2));
        }
      });

      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      
      createGround();
      createClouds();
      createTrees();

      
      connectToBackend();

      
      setupControls();

      
      document.getElementById('loading').style.display = 'none';

      
      animate();

      
      window.addEventListener('resize', onWindowResize);
    }

    
    function createGround() {
      const groundSize = 100;
      const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      
      const groundBody = new CANNON.Body({
        mass: 0, 
        shape: new CANNON.Plane()
      });
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(groundBody);


      for (let i = 0; i < 200; i++) {
        const grass = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          new THREE.MeshStandardMaterial({ color: 0x2d5016 })
        );
        grass.position.set(
          seededRandom.random() * groundSize - groundSize / 2,
          0.25,
          seededRandom.random() * groundSize - groundSize / 2
        );
        grass.castShadow = true;
        scene.add(grass);
      }

      
      const wallHeight = 5;
      const wallThickness = 1;
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.9
      });

      
      const northWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
        wallMaterial
      );
      northWall.position.set(0, wallHeight / 2, -groundSize / 2);
      northWall.castShadow = true;
      northWall.receiveShadow = true;
      scene.add(northWall);

      
      const southWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
        wallMaterial
      );
      southWall.position.set(0, wallHeight / 2, groundSize / 2);
      southWall.castShadow = true;
      southWall.receiveShadow = true;
      scene.add(southWall);

      
      const eastWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
        wallMaterial
      );
      eastWall.position.set(groundSize / 2, wallHeight / 2, 0);
      eastWall.castShadow = true;
      eastWall.receiveShadow = true;
      scene.add(eastWall);

      
      const westWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
        wallMaterial
      );
      westWall.position.set(-groundSize / 2, wallHeight / 2, 0);
      westWall.castShadow = true;
      westWall.receiveShadow = true;
      scene.add(westWall);

      
      
      const northWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(groundSize / 2, wallHeight / 2, wallThickness / 2))
      });
      northWallBody.position.set(0, wallHeight / 2, -groundSize / 2);
      world.addBody(northWallBody);

      
      const southWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(groundSize / 2, wallHeight / 2, wallThickness / 2))
      });
      southWallBody.position.set(0, wallHeight / 2, groundSize / 2);
      world.addBody(southWallBody);

      
      const eastWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, groundSize / 2))
      });
      eastWallBody.position.set(groundSize / 2, wallHeight / 2, 0);
      world.addBody(eastWallBody);

      
      const westWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, groundSize / 2))
      });
      westWallBody.position.set(-groundSize / 2, wallHeight / 2, 0);
      world.addBody(westWallBody);

    }

    function createClouds() {
      for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        for (let j = 0; j < 5; j++) {
          const puff = new THREE.Mesh(
            new THREE.SphereGeometry(seededRandom.random() * 2 + 1, 8, 8),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          puff.position.set((seededRandom.random() - 0.5) * 4, (seededRandom.random() - 0.5) * 2, (seededRandom.random() - 0.5) * 4);
          cloud.add(puff);
        }
        cloud.position.set(seededRandom.random() * 80 - 40, seededRandom.random() * 10 + 15, seededRandom.random() * 80 - 40);
        scene.add(cloud);
      }
    }

    function createTrees() {
      for (let i = 0; i < 30; i++) {
        const tree = new THREE.Group();


        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3, 0.4, 3, 8),
          new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        trunk.position.y = 1.5;
        trunk.castShadow = true;
        tree.add(trunk);


        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(1.5, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        leaves.position.y = 3.5;
        leaves.castShadow = true;
        tree.add(leaves);

        tree.position.set(
          seededRandom.random() * 80 - 40,
          0,
          seededRandom.random() * 80 - 40
        );

        scene.add(tree);
      }
    }

    
    async function loadCharacterPreviews() {
      const characters = ['soldier', 'robot', 'ninja', 'wizard', 'knight', 'archer', 'mech'];

      for (const char of characters) {
        const canvas = document.querySelector(`.character-preview[data-character="${char}"]`);
        if (!canvas) continue;

        
        const rect = canvas.getBoundingClientRect();
        const size = Math.min(rect.width, 200);

        const previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x1a1a2e);

        const previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        previewCamera.position.set(0, 2, 5);
        previewCamera.lookAt(0, 0, 0);

        const previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        previewRenderer.setSize(size, size);
        previewRenderer.setPixelRatio(window.devicePixelRatio);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 5, 5);
        previewScene.add(directionalLight);

        const model = await createCharacter(char);
        model.position.set(0, -1, 0);
        model.rotation.y = Math.PI; 
        previewScene.add(model);

        function animatePreview() {
          model.rotation.y += 0.01;
          previewRenderer.render(previewScene, previewCamera);
          requestAnimationFrame(animatePreview);
        }
        animatePreview();
      }
    }

    
    async function createCharacter(characterType) {
      const config = CHARACTER_CONFIG[characterType];
      if (!config) return createFallbackCharacter(characterType);

      if (loadedModels.has(characterType)) {
        const clone = loadedModels.get(characterType).clone();
        clone.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        return clone;
      }

      return new Promise((resolve) => {
        gltfLoader.load(
          config.model,
          (gltf) => {
            const model = gltf.scene;
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            model.scale.set(1.5, 1.5, 1.5);
            loadedModels.set(characterType, model.clone());
            resolve(model);
          },
          null,
          () => resolve(createFallbackCharacter(characterType))
        );
      });
    }

    
    function createFallbackCharacter(characterType) {
      const group = new THREE.Group();
      const config = CHARACTER_CONFIG[characterType] || {};
      const color = config.color || 0xff0000;

      
      const body = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
        new THREE.MeshStandardMaterial({ color })
      );
      body.position.y = 0.75;
      body.castShadow = true;
      group.add(body);

      
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 16, 16),
        new THREE.MeshStandardMaterial({ color })
      );
      head.position.y = 1.8;
      head.castShadow = true;
      group.add(head);

      return group;
    }

    
    async function connectToBackend() {
      try {
        const response = await sendToExtension('GAME_INIT');
        if (response.success) connected = true;
      } catch (error) {
        console.error('[Game] Connection error:', error);
      }
    }

    
    async function selectCharacter(character) {
      console.log('[Game] Selecting character:', character);

      
      if (!CHARACTER_CONFIG[character]) {
        console.error('[Game] Character not found in config:', character);
        return;
      }

      selectedCharacter = character;
      isCharacterSelected = true;
      console.log('[Game] Character config:', CHARACTER_CONFIG[character]);

      
      document.getElementById('character-selection').style.display = 'none';

      
      myPlayer = await createCharacter(character);
      myPlayer.position.set(0, 1, 0);
      myPlayer.rotation.y = 0; 
      scene.add(myPlayer);

      
      const config = CHARACTER_CONFIG[character];
      myHealth = config.health;
      updateHealthDisplay();

      
      const playerShape = new CANNON.Cylinder(0.5, 0.5, 2, 8); 
      myPlayerBody = new CANNON.Body({
        mass: 5, 
        position: new CANNON.Vec3(0, 1, 0),
        shape: playerShape,
        linearDamping: 0.9, 
        angularDamping: 0.9
      });
      myPlayerBody.fixedRotation = true; 
      myPlayerBody.updateMassProperties();
      world.addBody(myPlayerBody);

      console.log('[Game] Player physics body created');
      console.log('[Game] Mouse controls enabled - move mouse to aim');

      
      try {
        await sendToExtension('GAME_SELECT_CHARACTER', { character });
        console.log('[Game] Selected:', character);

        
        if (playerName) {
          await sendToExtension('GAME_SET_PLAYER_NAME', { playerName });
          console.log('[Game] Sent player name to backend:', playerName);
        }

        
        const displayName = CHARACTER_NAMES[character] || character;
        document.getElementById('character-name').textContent = `${displayName}`;
      } catch (error) {
        console.error('[Game] Failed to select character:', error);
      }
    }


    function updateGameState(state) {

      if (state.players && Array.isArray(state.players)) {
        state.players.forEach(p => {

          if (p.id === mySocketId) {
            console.log('[Game] Skipping self in gameState:', p.id);
            return;
          }

          if (!players.has(p.id)) {
            addPlayer(p.id, p.character);
          }
          updatePlayerPosition(p.id, p.position, p.rotation);
        });
      }

      if (state.blocks && Array.isArray(state.blocks)) {
        console.log('[Game] Received', state.blocks.length, 'blocks in game state');
        state.blocks.forEach(block => {
          if (!blocks.has(block.id)) {
            console.log('[Game] Adding existing block from game state:', block.id);
            placeBlock(block);
          }
        });
      }

      updatePlayerList();
    }

    async function addPlayer(id, character, playerName = null) {
      
      if (id === mySocketId) {
        console.log('[Game] Skipping addPlayer for self:', id);
        return;
      }

      if (players.has(id)) {
        console.log('[Game] Player already exists:', id);
        return;
      }

      console.log('[Game] Adding player:', id, character, playerName);

      
      const player = await createCharacter(character);
      scene.add(player);

      
      const displayName = playerName || CHARACTER_NAMES[character] || character;
      const nameLabel = createNameLabel(displayName);
      nameLabel.position.set(0, 3, 0); 
      player.add(nameLabel); 

      
      
      players.set(id, {
        model: player,
        nameLabel: nameLabel,
        character: character,
        playerName: playerName,
        targetPosition: { x: 0, y: 1, z: 0 },
        targetRotation: { x: 0, y: 0, z: 0 }
      });

      updatePlayerCount();
    }

    
    function createNameLabel(name) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;

      
      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      
      context.font = 'Bold 28px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(name, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(2, 0.5, 1);

      return sprite;
    }

    function removePlayer(id) {
      const player = players.get(id);
      if (player) {
        scene.remove(player.model);

        
        if (player.body) {
          world.removeBody(player.body);
        }

        players.delete(id);
        console.log('[Game] Removed player:', id);

        updatePlayerCount();
      }
    }

    function updatePlayerPosition(id, pos, rot) {
      const player = players.get(id);
      if (!player) return;

      
      player.targetPosition = { x: pos.x, y: pos.y, z: pos.z };
      if (rot) {
        player.targetRotation = { x: rot.x, y: rot.y, z: rot.z };
      }
    }

    
    function interpolatePlayers() {
      
      const lerpFactor = 0.85; 

      players.forEach((player, id) => {
        
        player.model.position.x += (player.targetPosition.x - player.model.position.x) * lerpFactor;
        player.model.position.y += (player.targetPosition.y - player.model.position.y) * lerpFactor;
        player.model.position.z += (player.targetPosition.z - player.model.position.z) * lerpFactor;

        
        player.model.rotation.x += (player.targetRotation.x - player.model.rotation.x) * lerpFactor;
        player.model.rotation.y += (player.targetRotation.y - player.model.rotation.y) * lerpFactor;
        player.model.rotation.z += (player.targetRotation.z - player.model.rotation.z) * lerpFactor;
      });
    }

    function updatePlayerList() {
      const list = document.getElementById('players');
      list.innerHTML = '';
      players.forEach((data, id) => {
        const div = document.createElement('div');
        div.className = 'player-item';
        const displayName = data.playerName || CHARACTER_NAMES[data.character] || data.character;
        div.textContent = displayName;
        list.appendChild(div);
      });
    }

    function updatePlayerCount() {
      const totalPlayers = players.size + 1; 
      const countEl = document.getElementById('player-count');
      if (countEl) {
        countEl.textContent = `Players Online: ${totalPlayers}`;
      }
      console.log('[Game] Player count updated:', totalPlayers);
    }

    
    function updateMovement() {
      if (!myPlayerBody || !isCharacterSelected) return;

      
      const edgeRotationSpeed = 0.02; 
      if (isAtEdge.left) {
        cameraYaw += edgeRotationSpeed; 
      }
      if (isAtEdge.right) {
        cameraYaw -= edgeRotationSpeed; 
      }
      if (isAtEdge.top) {
        cameraPitch -= edgeRotationSpeed * 0.5; 
      }
      if (isAtEdge.bottom) {
        cameraPitch += edgeRotationSpeed * 0.5; 
      }

      
      const maxPitch = Math.PI / 2 - 0.01; 
      const minPitch = -Math.PI / 2 + 0.01; 
      cameraPitch = Math.max(minPitch, Math.min(maxPitch, cameraPitch));

      
      if (isAtEdge.left || isAtEdge.right || isAtEdge.top || isAtEdge.bottom) {
        mouseNDC.x = (mouseX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(mouseY / window.innerHeight) * 2 + 1;
      }

      
      const config = CHARACTER_CONFIG[selectedCharacter];
      const charMoveSpeed = config ? config.moveSpeed : 0.15;
      const moveForce = charMoveSpeed * 100; 

      
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();

      
      camera.getWorldDirection(forward);
      forward.y = 0; 
      forward.normalize();

      
      right.crossVectors(camera.up, forward).normalize();

      
      const moveDirection = new THREE.Vector3(0, 0, 0);

      
      if (keys['w'] || keys['W']) {
        moveDirection.add(forward);
      }
      if (keys['s'] || keys['S']) {
        moveDirection.sub(forward);
      }

      
      if (keys['a'] || keys['A']) {
        moveDirection.add(right);
      }
      if (keys['d'] || keys['D']) {
        moveDirection.sub(right);
      }

      
      if (moveDirection.length() > 0) {
        moveDirection.normalize();
        myPlayerBody.velocity.x = moveDirection.x * moveForce;
        myPlayerBody.velocity.z = moveDirection.z * moveForce;

        
        const angle = Math.atan2(moveDirection.x, moveDirection.z);
        myPlayer.rotation.y = angle; 
      } else {
        
        myPlayerBody.velocity.x = 0;
        myPlayerBody.velocity.z = 0;
      }

      
      if (keys[' '] && Math.abs(myPlayerBody.velocity.y) < 0.1) {
        myPlayerBody.velocity.y = 8; 
      }

      
      const boundary = 48;
      if (myPlayerBody.position.x > boundary) myPlayerBody.position.x = boundary;
      if (myPlayerBody.position.x < -boundary) myPlayerBody.position.x = -boundary;
      if (myPlayerBody.position.z > boundary) myPlayerBody.position.z = boundary;
      if (myPlayerBody.position.z < -boundary) myPlayerBody.position.z = -boundary;

      
      isGrounded = Math.abs(myPlayerBody.velocity.y) < 0.1 && myPlayerBody.position.y <= 1.1;

      
      const now = Date.now();
      if (connected && (now - lastNetworkUpdate) >= NETWORK_UPDATE_INTERVAL) {
        
        const dx = Math.abs(myPlayerBody.position.x - lastPositionSent.x);
        const dy = Math.abs(myPlayerBody.position.y - lastPositionSent.y);
        const dz = Math.abs(myPlayerBody.position.z - lastPositionSent.z);

        if (dx > 0.01 || dy > 0.01 || dz > 0.01) {
          lastNetworkUpdate = now;
          lastPositionSent = {
            x: myPlayerBody.position.x,
            y: myPlayerBody.position.y,
            z: myPlayerBody.position.z
          };

          sendToExtension('GAME_PLAYER_MOVE', {
            position: lastPositionSent,
            rotation: { x: myPlayer.rotation.x, y: myPlayer.rotation.y, z: myPlayer.rotation.z }
          }).catch(() => {}); 
        }
      }

      
      if (myPlayer) {
        
        const offsetX = Math.sin(cameraYaw) * cameraDistance;
        const offsetZ = Math.cos(cameraYaw) * cameraDistance;

        camera.position.set(
          myPlayer.position.x + offsetX,
          myPlayer.position.y + cameraHeight,
          myPlayer.position.z + offsetZ
        );

        
        const lookAtPoint = new THREE.Vector3(
          myPlayer.position.x - Math.sin(cameraYaw) * 10,
          myPlayer.position.y + cameraHeight - (cameraPitch * 10), 
          myPlayer.position.z - Math.cos(cameraYaw) * 10
        );

        camera.lookAt(lookAtPoint);
      }
    }

    
    function shoot() {
      if (!myPlayer || !isCharacterSelected || !connected) {
        console.log('[Game] Cannot shoot - myPlayer:', !!myPlayer, 'isCharacterSelected:', isCharacterSelected, 'connected:', connected);
        return;
      }

      
      const config = CHARACTER_CONFIG[selectedCharacter];
      if (!config) {
        console.error('[Game] No config found for character:', selectedCharacter);
        return;
      }

      const fireRate = config.fireRate;
      const now = Date.now();

      if (now - lastShotTime < fireRate) {
        
        return;
      }

      lastShotTime = now;
      console.log('[Game] Shooting with character:', selectedCharacter, 'fireRate:', fireRate);

      
      
      raycaster.setFromCamera(mouseNDC, camera);
      const direction = raycaster.ray.direction.clone();
      direction.normalize();

      
      recentShots.push({
        time: now,
        direction: { x: direction.x, y: direction.y, z: direction.z },
        position: { x: myPlayer.position.x, y: myPlayer.position.y + 1.5, z: myPlayer.position.z }
      });

      
      recentShots = recentShots.filter(shot => now - shot.time < 2000);

      sendToExtension('GAME_PLAYER_SHOOT', {
        position: { x: myPlayer.position.x, y: myPlayer.position.y + 1.5, z: myPlayer.position.z },
        direction: { x: direction.x, y: direction.y, z: direction.z }, 
        character: selectedCharacter, 
        ownerId: mySocketId 
      }).catch((error) => {
        console.error('[Game] Failed to shoot:', error);
      });
    }

    function createBullet(data) {
      
      const shooterConfig = CHARACTER_CONFIG[data.character];
      const bulletSpeed = shooterConfig ? shooterConfig.bulletSpeed : 20;
      const bulletDamage = shooterConfig ? shooterConfig.damage : 10;

      
      let bulletOwnerId = data.ownerId || data.playerId || data.socketId;

      
      if (!bulletOwnerId && recentShots.length > 0) {
        
        const now = Date.now();
        for (const shot of recentShots) {
          
          const dirMatch = (
            Math.abs(shot.direction.x - data.direction.x) < 0.1 &&
            Math.abs(shot.direction.y - data.direction.y) < 0.1 &&
            Math.abs(shot.direction.z - data.direction.z) < 0.1
          );

          
          const posMatch = data.position && (
            Math.abs(shot.position.x - data.position.x) < 2 &&
            Math.abs(shot.position.y - data.position.y) < 2 &&
            Math.abs(shot.position.z - data.position.z) < 2
          );

          
          const timeMatch = (now - shot.time) < 1000;

          if (dirMatch && posMatch && timeMatch) {
            
            bulletOwnerId = mySocketId;
            console.log('[Game] Matched bullet to our recent shot - marking as ours');
            break;
          }
        }
      }

      const isMyBullet = bulletOwnerId === mySocketId;
      console.log('[Game] Creating bullet - Owner:', bulletOwnerId, 'IsMyBullet:', isMyBullet);

      
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 })
      );
      bullet.position.set(data.position.x, data.position.y, data.position.z);

      
      const bulletShape = new CANNON.Sphere(0.15);
      const bulletBody = new CANNON.Body({
        mass: 0.1, 
        shape: bulletShape,
        position: new CANNON.Vec3(data.position.x, data.position.y, data.position.z),
        velocity: new CANNON.Vec3(
          data.direction.x * bulletSpeed, 
          data.direction.y * bulletSpeed,
          data.direction.z * bulletSpeed
        ),
        collisionFilterGroup: 1,
        collisionFilterMask: -1
      });

      
      bulletBody.addEventListener('collide', (event) => {
        const hitBody = event.body;

        
        if (hitBody === myPlayerBody) {
          
          const bulletOwnerId = data.ownerId || data.playerId || data.socketId;
          if (bulletOwnerId === mySocketId) {
            console.log('[Game] Skipping self-damage from own bullet (ownerId:', bulletOwnerId, ')');
            return;
          }

          
          myHealth -= bulletDamage; 
          updateHealthDisplay();
          console.log('[Game] Hit by bullet! Damage:', bulletDamage, 'Health:', myHealth, 'Shooter:', bulletOwnerId);

          
          world.removeBody(bulletBody);
          scene.remove(bullet);
          const bulletIndex = bullets.findIndex(b => b.userData.body === bulletBody);
          if (bulletIndex !== -1) bullets.splice(bulletIndex, 1);

          
          if (myHealth <= 0) {
            handlePlayerDeath();
          }
          return;
        }

        
        blocks.forEach((blockData, blockId) => {
          if (hitBody === blockData.body) {
            console.log('[Game] Bullet hit block:', blockId);

            
            blockData.mesh.userData.health -= 1;
            const health = blockData.mesh.userData.health;

            
            const healthPercent = health / blockData.mesh.userData.maxHealth;
            if (healthPercent <= 0.25) {
              blockData.mesh.material.color.setHex(0x330000); 
            } else if (healthPercent <= 0.5) {
              blockData.mesh.material.color.setHex(0x663300); 
            } else if (healthPercent <= 0.75) {
              blockData.mesh.material.color.setHex(0x7a4f2f); 
            }

            
            if (health <= 0) {
              console.log('[Game] Block destroyed by bullet:', blockId);
              destroyBlock(blockId);

              
              sendToExtension('GAME_DESTROY_BLOCK', { id: blockId }).catch(() => {});
            }

            
            world.removeBody(bulletBody);
            scene.remove(bullet);
            const bulletIndex = bullets.findIndex(b => b.userData.body === bulletBody);
            if (bulletIndex !== -1) bullets.splice(bulletIndex, 1);
            return;
          }
        });

        
        players.forEach((playerData, id) => {
          if (playerData.body && hitBody === playerData.body && data.ownerId !== id) {
            console.log('[Game] Bullet hit player:', id);
            
          }
        });
      });

      world.addBody(bulletBody);

      bullet.userData = {
        dir: data.direction,
        speed: 0.5,
        id: data.id,
        ownerId: bulletOwnerId || null, 
        body: bulletBody 
      };

      scene.add(bullet);
      bullets.push(bullet);
    }

    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bulletBody = bullet.userData.body;

        
        if (bulletBody && bulletBody.world) {
          bullet.position.copy(bulletBody.position);
          bullet.quaternion.copy(bulletBody.quaternion);
        }

        
        if (!bulletBody || !bulletBody.world || bullet.position.length() > 100) {
          if (bulletBody && bulletBody.world) {
            world.removeBody(bulletBody);
          }
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }
    }

    function updateHealthDisplay() {
      const healthEl = document.getElementById('health');
      healthEl.textContent = `HP: ${myHealth}`;

      
      if (myHealth > 70) {
        healthEl.style.color = '#00ff00'; 
      } else if (myHealth > 30) {
        healthEl.style.color = '#ffaa00'; 
      } else {
        healthEl.style.color = '#ff0000'; 
      }
    }

    function handlePlayerDeath() {
      console.log('[Game] You died! Respawning...');

      
      playerStats.deaths += 1;

      
      alert(`ðŸ’€ YOU DIED! ðŸ’€\n\nKills: ${playerStats.kills}\nDeaths: ${playerStats.deaths}\nScore: ${playerStats.score}\nK/D Ratio: ${(playerStats.kills / Math.max(1, playerStats.deaths)).toFixed(2)}\n\nRespawning...`);

      
      myHealth = 100;
      updateHealthDisplay();

      
      const respawnX = Math.random() * 40 - 20;
      const respawnZ = Math.random() * 40 - 20;

      if (myPlayer) {
        myPlayer.position.set(respawnX, 1, respawnZ);
      }

      if (myPlayerBody) {
        myPlayerBody.position.set(respawnX, 1, respawnZ);
        myPlayerBody.velocity.set(0, 0, 0); 
      }
    }

    

    
    function createGhostBlock() {
      if (ghostBlock) return; 

      
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
        wireframe: false
      });

      
      const wireframeGeo = new THREE.EdgesGeometry(geometry);
      const wireframeMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
      const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);

      ghostBlock = new THREE.Mesh(geometry, material);
      ghostBlock.add(wireframe);
      ghostBlock.userData.isValid = true; 

      scene.add(ghostBlock);
      console.log('[Game] Ghost block created');
    }

    
    function updateGhostBlock() {
      if (!ghostBlock || !myPlayer) return;

      
      raycaster.setFromCamera(mouseNDC, camera);

      
      const buildableObjects = [];
      scene.traverse((obj) => {
        if (obj.isMesh && obj !== ghostBlock && obj !== myPlayer) {
          
          buildableObjects.push(obj);
        }
      });

      
      blocks.forEach((blockData) => {
        if (blockData.mesh && blockData.mesh !== ghostBlock) {
          buildableObjects.push(blockData.mesh);
        }
      });

      const intersects = raycaster.intersectObjects(buildableObjects, false);

      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPoint = hit.point;
        const hitNormal = hit.normal;

        
        let placeX = Math.round(hitPoint.x + hitNormal.x * 0.5);
        let placeY = Math.round(hitPoint.y + hitNormal.y * 0.5);
        let placeZ = Math.round(hitPoint.z + hitNormal.z * 0.5);

        
        if (placeY < 0.5) placeY = 0.5;

        
        ghostBlock.position.set(placeX, placeY, placeZ);

        
        let isValid = true;
        let overlapCount = 0;
        blocks.forEach((blockData) => {
          const blockPos = blockData.mesh.position;
          const distance = ghostBlock.position.distanceTo(blockPos);
          if (distance < 0.5) { 
            isValid = false;
            overlapCount++;
          }
        });

        
        if (isValid) {
          ghostBlock.material.color.setHex(0x00ff00); 
          ghostBlock.userData.isValid = true;
        } else {
          ghostBlock.material.color.setHex(0xff0000); 
          ghostBlock.userData.isValid = false;
          console.log('[Game] Ghost block invalid - overlapping with', overlapCount, 'block(s)');
        }
      } else {
        
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();

        const placeDistance = 3;
        ghostBlock.position.set(
          Math.round(myPlayer.position.x + forward.x * placeDistance),
          0.5,
          Math.round(myPlayer.position.z + forward.z * placeDistance)
        );
        ghostBlock.material.color.setHex(0x00ff00);
        ghostBlock.userData.isValid = true;
      }
    }

    
    function removeGhostBlock() {
      if (ghostBlock) {
        scene.remove(ghostBlock);
        ghostBlock = null;
        console.log('[Game] Ghost block removed');
      }
    }

    function placeBlock(data) {
      console.log('[Game] placeBlock called with data:', data);

      if (!data || !data.id) {
        console.error('[Game] Invalid block data - missing id:', data);
        return;
      }

      if (blocks.has(data.id)) {
        console.log('[Game] Block already exists with id:', data.id);
        return;
      }

      if (!data.position) {
        console.error('[Game] Invalid block data - missing position:', data);
        return;
      }

      
      const block = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshStandardMaterial({ color: 0x8b4513 })
      );
      block.position.set(data.position.x, data.position.y, data.position.z);
      block.castShadow = true;
      block.receiveShadow = true;

      
      const blockShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)); 
      const blockBody = new CANNON.Body({
        mass: 0, 
        shape: blockShape,
        position: new CANNON.Vec3(data.position.x, data.position.y, data.position.z)
      });
      world.addBody(blockBody);

      block.userData = {
        health: 4, 
        maxHealth: 4,
        id: data.id,
        body: blockBody 
      };

      scene.add(block);
      blocks.set(data.id, { mesh: block, body: blockBody });

      console.log('[Game] Block successfully placed! ID:', data.id, 'Position:', data.position, 'Total blocks:', blocks.size);
    }

    function destroyBlock(id) {
      const blockData = blocks.get(id);
      if (blockData) {
        
        scene.remove(blockData.mesh);

        
        if (blockData.body) {
          world.removeBody(blockData.body);
        }

        blocks.delete(id);
        console.log('[Game] Block destroyed:', id);
      }
    }

    
    function setupControls() {
      window.addEventListener('keydown', (e) => {
        
        if (e.repeat) {
          
          keys[e.key] = true;
          return;
        }

        keys[e.key] = true;

        
        if ((e.key === 'e' || e.key === 'E') && isCharacterSelected && myPlayer && connected) {
          if (!buildMode) {
            
            buildMode = true;
            createGhostBlock();
            console.log('[Game] Build mode ON - move mouse to position, press E again to place');
          } else {
            
            console.log('[Game] E pressed in build mode. Ghost exists:', !!ghostBlock, 'Valid:', ghostBlock?.userData?.isValid);

            if (ghostBlock && ghostBlock.userData.isValid) {
              const pos = ghostBlock.position;
              console.log('[Game] Placing block at:', { x: pos.x, y: pos.y, z: pos.z });

              
              const blockId = `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

              
              placeBlock({
                id: blockId,
                position: { x: pos.x, y: pos.y, z: pos.z },
                type: 'grass',
                ownerId: mySocketId
              });


              sendToExtension('GAME_PLACE_BLOCK', {
                id: blockId,
                position: { x: pos.x, y: pos.y, z: pos.z },
                blockType: 'grass'
              }).then((response) => {
                console.log('[Game] Block placement request sent successfully, response:', response);
              }).catch((error) => {
                console.error('[Game] Failed to send block placement:', error);
                
                destroyBlock(blockId);
              });
            } else if (!ghostBlock) {
              console.log('[Game] Cannot place block - ghost block does not exist');
            } else if (!ghostBlock.userData.isValid) {
              console.log('[Game] Cannot place block - invalid position (red = overlapping)');
            }

            
            buildMode = false;
            removeGhostBlock();
            console.log('[Game] Build mode OFF');
          }
        }

        
        if (e.key === 'Escape' && buildMode) {
          buildMode = false;
          removeGhostBlock();
          console.log('[Game] Build mode cancelled');
        }
      });

      window.addEventListener('keyup', (e) => { keys[e.key] = false; });

      
      window.addEventListener('click', (e) => {
        if (isCharacterSelected) {
          shoot();
        }
      });
    }

    
    const timeStep = 1 / 60; 
    function animate() {
      requestAnimationFrame(animate);

      
      if (world) {
        world.step(timeStep);

        
        if (myPlayer && myPlayerBody) {
          myPlayer.position.copy(myPlayerBody.position);
          myPlayer.quaternion.copy(myPlayerBody.quaternion);
        }

        
        players.forEach((playerData) => {
          if (playerData.body) {
            playerData.model.position.copy(playerData.body.position);
          }
        });
      }

      updateMovement();
      interpolatePlayers(); 
      updateBullets();

      
      if (buildMode && ghostBlock) {
        updateGhostBlock();
      }

      renderer.render(scene, camera);
    }

    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    
    init();
  </script>
</body>
</html>
