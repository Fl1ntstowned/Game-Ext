<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer 3D Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      pointer-events: none;
    }

    #name-input-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }

    #name-input-screen h1 {
      color: white;
      font-size: 56px;
      margin-bottom: 20px;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
    }

    #name-input-screen p {
      color: #aaa;
      font-size: 18px;
      margin-bottom: 40px;
    }

    #player-name-input {
      padding: 20px 40px;
      font-size: 24px;
      border: 3px solid #667eea;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      min-width: 300px;
      margin-bottom: 30px;
      pointer-events: all;
    }

    #player-name-input::placeholder {
      color: #777;
    }

    #name-submit-btn {
      padding: 20px 60px;
      font-size: 28px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    #name-submit-btn:hover {
      transform: scale(1.05) translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    #character-selection {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    #character-selection h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #characters-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      max-width: 90vw;
      max-height: 80vh;
      width: clamp(600px, 80vw, 1400px);
      padding: 0 10px;
      overflow-y: auto;
    }

    .character-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid #667eea;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      pointer-events: all;
    }

    .character-btn:hover {
      transform: scale(1.05);
      border-color: #764ba2;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
    }

    .character-preview {
      width: 100%;
      aspect-ratio: 1;
      max-width: 200px;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
    }

    .character-name {
      font-size: clamp(14px, 3vw, 20px);
      font-weight: bold;
      color: white;
      text-transform: uppercase;
    }

    @media (max-width: 768px) {
      #characters-list {
        grid-template-columns: repeat(2, 1fr);
        width: 95vw;
      }
    }

    @media (max-width: 480px) {
      #characters-list {
        grid-template-columns: repeat(2, minmax(120px, 1fr));
        width: 95vw;
      }
    }

    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    #player-list {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      min-width: 200px;
      pointer-events: none;
    }

    #player-list h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #44ff88;
    }

    .player-item {
      padding: 5px 0;
      font-size: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    #controls-help {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      font-size: 12px;
      pointer-events: none;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 1000;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
      top: 0;
    }

    #crosshair::after {
      width: 20px;
      height: 2px;
      left: 0;
      top: 9px;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 3000;
    }
  </style>
</head>
<body>
  <!-- Loading -->
  <div id="loading">Loading game...</div>

  <!-- UI Container -->
  <div id="ui">
    <!-- HUD -->
    <div id="hud">
      <div id="health" style="font-size: 20px; font-weight: bold; color: #00ff00;">HP: 100</div>
      <div id="character-name" style="margin-top: 5px;">Character: None</div>
      <div id="player-count" style="margin-top: 10px; color: #44ff88; font-weight: bold;">Players Online: 1</div>
    </div>

    <!-- Player List -->
    <div id="player-list">
      <h3>Players Online</h3>
      <div id="players"></div>
    </div>

    <!-- Controls Help -->
    <div id="controls-help">
      <div><strong>Controls:</strong></div>
      <div>WASD - Move</div>
      <div>SPACE - Jump</div>
      <div>Mouse - Aim</div>
      <div>Left Click - Shoot</div>
      <div>E - Place Block</div>
      <div>ESC - Pause</div>
    </div>

    <!-- Crosshair -->
    <div id="crosshair"></div>
  </div>

  <!-- Character Selection -->
  <!-- Player Name Input (shows first) -->
  <div id="name-input-screen">
    <h1>ðŸŽ® 3D MULTIPLAYER ARENA ðŸŽ®</h1>
    <p>Enter your name to track your stats across games</p>
    <input type="text" id="player-name-input" placeholder="Enter your name..." maxlength="20" />
    <button id="name-submit-btn">START GAME</button>
  </div>

  <!-- Character Selection (shows after name) -->
  <div id="character-selection">
    <h1>Select Your Character</h1>
    <div id="characters-list">
      <button class="character-btn" data-character="soldier">
        <canvas class="character-preview" data-character="soldier"></canvas>
        <span class="character-name">SOLDIER</span>
      </button>
      <button class="character-btn" data-character="robot">
        <canvas class="character-preview" data-character="robot"></canvas>
        <span class="character-name">ROBOT</span>
      </button>
      <button class="character-btn" data-character="ninja">
        <canvas class="character-preview" data-character="ninja"></canvas>
        <span class="character-name">NINJA</span>
      </button>
      <button class="character-btn" data-character="wizard">
        <canvas class="character-preview" data-character="wizard"></canvas>
        <span class="character-name">WIZARD</span>
      </button>
      <button class="character-btn" data-character="knight">
        <canvas class="character-preview" data-character="knight"></canvas>
        <span class="character-name">KNIGHT</span>
      </button>
      <button class="character-btn" data-character="archer">
        <canvas class="character-preview" data-character="archer"></canvas>
        <span class="character-name">ARCHER</span>
      </button>
    </div>
  </div>

  <!-- CannonJS Physics Engine (on-chain) -->
  <script src="/content/39df128491c33911ebff0afd1130c8b534311ed5258bbbd29e90ab65e0bf9b2bi0"></script>

  <!-- Game Code -->
  <script type="module">
    // Import Three.js from on-chain module
    import * as THREE from '/content/a4a6f99205628bdc3ca2143a4e380f7ebc576b4414c16dffdb34be28337ffe83i0';

    // Make THREE available globally BEFORE importing loaders (they need it)
    // Use Object.assign to copy all properties including non-enumerable ones
    window.THREE = Object.assign({}, THREE);

    // Copy all properties from THREE to ensure we get everything
    Object.getOwnPropertyNames(THREE).forEach(key => {
      if (!(key in window.THREE)) {
        try {
          window.THREE[key] = THREE[key];
        } catch (e) {
          // Some properties may not be writable
        }
      }
    });

    // Import GLTF, DRACO, and OrbitControls (they will add themselves to window.THREE)
    await import('/content/00ae91a4f7f4f6fa98c1deb0f57359079f7b5299094378ff15fa1c7f4366db3ci0');
    await import('/content/d9f5134fdd4a1ae7a5c3fe1b42876cc4e18f4ce404a39394f9157679c60e965fi0');
    await import('/content/183616632d0baeeaf8bc7bbda1766ea1fb19e76f63fdf136456e075bf19ed08di0');

    // Wait for CannonJS to load
    await new Promise(resolve => {
      if (window.CANNON) {
        resolve();
      } else {
        const checkCannon = setInterval(() => {
          if (window.CANNON) {
            clearInterval(checkCannon);
            resolve();
          }
        }, 100);
      }
    });


    // ===== GLOBALS =====
    let scene, camera, renderer;
    let world; // CannonJS physics world
    let myPlayer = null;
    let myPlayerBody = null; // Physics body for player
    let mySocketId = null; // Track our own socket ID to prevent duplicates
    let myHealth = 100;
    let players = new Map();
    let blocks = new Map();
    let bullets = [];

    // Player controls
    let keys = {};
    let selectedCharacter = null;
    let isCharacterSelected = false;
    let connected = false;
    let playerName = null; // Player's name for stats tracking
    let playerStats = { kills: 0, deaths: 0, score: 0 }; // Current session stats

    // Camera controls (FPS-style) - mouse tracking without pointer lock
    let cameraYaw = 0; // Horizontal rotation (left/right)
    let cameraPitch = 0.3; // Vertical rotation (up/down)
    const cameraDistance = 5; // Distance behind player
    const cameraHeight = 2; // Height above player
    let mouseX = 0;
    let mouseY = 0;
    let lastMouseX = window.innerWidth / 2;
    let lastMouseY = window.innerHeight / 2;

    // CHARACTER CONFIGURATION - Models and Stats
    const CHARACTER_CONFIG = {
      soldier: {
        model: '/content/1c745ab450f076f8e8d8a262f081429a2ce00656d33dfd550c77268b7802167fi0',
        health: 120, // Strongest
        damage: 15, // High damage
        fireRate: 800, // Slower shooting
        bulletSpeed: 18, // Slower bullets
        moveSpeed: 0.14, // Slower movement
        color: 0x556b2f
      },
      robot: {
        model: '/content/c781f4d5a796472b34cc8cad584963a3b293c018d737ef281844a7a326f62cdfi0',
        health: 100, // Balanced
        damage: 12, // Balanced damage
        fireRate: 600, // Balanced
        bulletSpeed: 20, // Balanced
        moveSpeed: 0.15, // Balanced
        color: 0x808080
      },
      ninja: {
        model: '/content/285f271618ce9c7280e0d165bdfffb4a6b4111ddf638a363d483a42264e98cebi0',
        health: 80, // Weak
        damage: 10, // Low damage
        fireRate: 400, // VERY fast shooting
        bulletSpeed: 25, // Fast bullets
        moveSpeed: 0.20, // FASTEST movement
        color: 0x2f4f4f
      },
      wizard: {
        model: '/content/1871e1f6f357081de637d08c6a500f4d1f9658b99a0041465afbcbd97247eb20i0',
        health: 90, // Medium-low
        damage: 18, // HIGH damage
        fireRate: 1000, // VERY slow shooting
        bulletSpeed: 15, // Slow bullets
        moveSpeed: 0.13, // Slow movement
        color: 0x4b0082
      },
      knight: {
        model: '/content/a056eee27b584653d7a974ba1eb3951a2b11f6368207fbcb5f6fd32df6699677i0',
        health: 130, // TANKIEST
        damage: 10, // Low damage
        fireRate: 900, // Slow shooting
        bulletSpeed: 16, // Slow bullets
        moveSpeed: 0.12, // SLOWEST movement
        color: 0xc0c0c0
      },
      archer: {
        model: '/content/2e669b2290d6d7c18df10c98d6a4b85dc8cb42fa3387eff4d7bba5554cf966d6i0',
        health: 70, // WEAKEST
        damage: 8, // Lowest damage
        fireRate: 300, // FASTEST shooting
        bulletSpeed: 30, // FASTEST bullets (longest range)
        moveSpeed: 0.16, // Fast movement
        color: 0x228b22
      }
    };

    // GLTF Loader setup
    let gltfLoader = null;
    let loadedModels = new Map(); // Cache loaded models

    // Movement
    const moveSpeed = 0.15;
    const jumpPower = 0.4;
    let velocity = { x: 0, y: 0, z: 0 };
    let isGrounded = false;

    // Shooting cooldown
    let lastShotTime = 0;

    // Network optimization - throttle position updates
    let lastPositionSent = { x: 0, y: 0, z: 0 };
    let lastNetworkUpdate = 0;
    const NETWORK_UPDATE_INTERVAL = 50; // Send updates every 50ms (20 per second)

    // postMessage request tracking
    let messageRequestId = 0;
    const pendingRequests = new Map();

    // ===== CHARACTER COLORS =====
    const CHARACTER_COLORS = {
      soldier: 0x00ff00,
      robot: 0x888888,
      ninja: 0x000000,
      wizard: 0x9900ff,
      knight: 0xffaa00,
      archer: 0x00ffff
    };

    // ===== POSTMESSAGE COMMUNICATION =====
    function sendToExtension(type, data = {}) {
      return new Promise((resolve, reject) => {
        const requestId = ++messageRequestId;
        pendingRequests.set(requestId, { resolve, reject });

        const message = { type: type, requestId: requestId, ...data };

        // Send to all window contexts (for sandboxed iframes)
        window.postMessage(message, '*');
        if (window.parent && window.parent !== window) {
          window.parent.postMessage(message, '*');
        }
        if (window.top && window.top !== window) {
          window.top.postMessage(message, '*');
        }

        // Timeout after 10 seconds
        setTimeout(() => {
          if (pendingRequests.has(requestId)) {
            pendingRequests.delete(requestId);
            reject(new Error('Request timeout'));
          }
        }, 10000);
      });
    }

    // Listen for responses from extension
    window.addEventListener('message', (event) => {
      const message = event.data;
      if (!message || !message.type) return;

      // Handle request responses
      if (message.requestId && pendingRequests.has(message.requestId)) {
        const { resolve } = pendingRequests.get(message.requestId);
        pendingRequests.delete(message.requestId);
        resolve(message);
        return;
      }

      // Handle server notifications (no requestId)
      switch (message.type) {
        case 'GAME_CONNECTED':
          connected = true;
          break;

        case 'yourSocketId':
          mySocketId = message.id || message.data;
          break;

        case 'GAME_DISCONNECTED':
          connected = false;
          break;

        case 'GAME_STATE':
          updateGameState(message.state);
          break;

        case 'GAME_PLAYER_JOINED':
          addPlayer(message.id, message.character);
          updatePlayerList();
          break;

        case 'GAME_PLAYER_LEFT':
          removePlayer(message.id);
          updatePlayerList();
          break;

        case 'GAME_PLAYER_MOVED':
          updatePlayerPosition(message.id, message.position, message.rotation);
          break;

        case 'GAME_BULLET_FIRED':
          createBullet(message.bullet);
          break;

        case 'GAME_BLOCK_PLACED':
          placeBlock(message.block);
          break;

        case 'GAME_BLOCK_DESTROYED':
          destroyBlock(message.id);
          break;
      }
    });

    // ===== INITIALIZATION =====
    function init() {

      // Setup NAME INPUT handler
      const nameInput = document.getElementById('player-name-input');
      const nameSubmitBtn = document.getElementById('name-submit-btn');

      // Submit name on button click or Enter key
      const submitName = () => {
        const name = nameInput.value.trim();
        if (name.length > 0) {
          playerName = name;
          // Hide name screen, show character selection
          document.getElementById('name-input-screen').style.display = 'none';
          document.getElementById('character-selection').style.display = 'flex';

          // Load character previews NOW that the screen is visible
          setTimeout(() => loadCharacterPreviews(), 100);
        } else {
          alert('Please enter a name!');
        }
      };

      nameSubmitBtn.addEventListener('click', submitName);
      nameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitName();
      });

      // Setup character selection buttons
      document.querySelectorAll('.character-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const character = btn.getAttribute('data-character');
          selectCharacter(character);
        });
      });

      // Initialize CannonJS Physics World
      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0); // Earth gravity
      world.broadphase = new CANNON.NaiveBroadphase();
      world.solver.iterations = 10;

      // Initialize GLTF Loader with DRACO support
      const dracoLoader = new window.THREE.DRACOLoader();
      dracoLoader.setDecoderPath('/content/');

      gltfLoader = new window.THREE.GLTFLoader();
      gltfLoader.setDRACOLoader(dracoLoader);

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Mouse movement controls camera rotation (works in iframes without pointer lock)
      let mouseMoveCount = 0;
      document.addEventListener('mousemove', (e) => {
        if (!myPlayer) return;

        // Get mouse position
        mouseX = e.clientX;
        mouseY = e.clientY;

        // Calculate mouse movement delta
        const deltaX = mouseX - lastMouseX;
        const deltaY = mouseY - lastMouseY;

        // Update last position
        lastMouseX = mouseX;
        lastMouseY = mouseY;

        // Mouse sensitivity
        const sensitivity = 0.003;

        // Update yaw (left/right) and pitch (up/down)
        cameraYaw -= deltaX * sensitivity;
        cameraPitch += deltaY * sensitivity; // + for non-inverted (mouse up = look up)

        // Clamp pitch to prevent camera flipping
        const maxPitch = Math.PI / 2 - 0.1; // Almost straight up
        const minPitch = -Math.PI / 2 + 0.1; // Almost straight down
        cameraPitch = Math.max(minPitch, Math.min(maxPitch, cameraPitch));

        // Debug log every 100 moves
        mouseMoveCount++;
        if (mouseMoveCount % 100 === 0) {
          console.log('[Game] Mouse moving - Yaw:', cameraYaw.toFixed(2), 'Pitch:', cameraPitch.toFixed(2));
        }
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);

      // Environment
      createGround();
      createClouds();
      createTrees();

      // Connect to backend
      connectToBackend();

      // Controls
      setupControls();

      // Remove loading
      document.getElementById('loading').style.display = 'none';

      // Start animation
      animate();

      // Window resize
      window.addEventListener('resize', onWindowResize);
    }

    // ===== ENVIRONMENT =====
    function createGround() {
      const groundSize = 100;
      const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // CREATE PHYSICS BODY FOR GROUND (static - mass 0)
      const groundBody = new CANNON.Body({
        mass: 0, // Static - won't move
        shape: new CANNON.Plane()
      });
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(groundBody);

      // Grass patches
      for (let i = 0; i < 200; i++) {
        const grass = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          new THREE.MeshStandardMaterial({ color: 0x2d5016 })
        );
        grass.position.set(
          Math.random() * groundSize - groundSize / 2,
          0.25,
          Math.random() * groundSize - groundSize / 2
        );
        grass.castShadow = true;
        scene.add(grass);
      }

      // BOUNDARY WALLS - Create sandbox arena
      const wallHeight = 5;
      const wallThickness = 1;
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.9
      });

      // North wall
      const northWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
        wallMaterial
      );
      northWall.position.set(0, wallHeight / 2, -groundSize / 2);
      northWall.castShadow = true;
      northWall.receiveShadow = true;
      scene.add(northWall);

      // South wall
      const southWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, wallHeight, wallThickness),
        wallMaterial
      );
      southWall.position.set(0, wallHeight / 2, groundSize / 2);
      southWall.castShadow = true;
      southWall.receiveShadow = true;
      scene.add(southWall);

      // East wall
      const eastWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
        wallMaterial
      );
      eastWall.position.set(groundSize / 2, wallHeight / 2, 0);
      eastWall.castShadow = true;
      eastWall.receiveShadow = true;
      scene.add(eastWall);

      // West wall
      const westWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, wallHeight, groundSize),
        wallMaterial
      );
      westWall.position.set(-groundSize / 2, wallHeight / 2, 0);
      westWall.castShadow = true;
      westWall.receiveShadow = true;
      scene.add(westWall);

      // CREATE PHYSICS BODIES FOR WALLS (static)
      // North wall physics
      const northWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(groundSize / 2, wallHeight / 2, wallThickness / 2))
      });
      northWallBody.position.set(0, wallHeight / 2, -groundSize / 2);
      world.addBody(northWallBody);

      // South wall physics
      const southWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(groundSize / 2, wallHeight / 2, wallThickness / 2))
      });
      southWallBody.position.set(0, wallHeight / 2, groundSize / 2);
      world.addBody(southWallBody);

      // East wall physics
      const eastWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, groundSize / 2))
      });
      eastWallBody.position.set(groundSize / 2, wallHeight / 2, 0);
      world.addBody(eastWallBody);

      // West wall physics
      const westWallBody = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, groundSize / 2))
      });
      westWallBody.position.set(-groundSize / 2, wallHeight / 2, 0);
      world.addBody(westWallBody);

    }

    function createClouds() {
      for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        for (let j = 0; j < 5; j++) {
          const puff = new THREE.Mesh(
            new THREE.SphereGeometry(Math.random() * 2 + 1, 8, 8),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          puff.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 4);
          cloud.add(puff);
        }
        cloud.position.set(Math.random() * 80 - 40, Math.random() * 10 + 15, Math.random() * 80 - 40);
        scene.add(cloud);
      }
    }

    function createTrees() {
      for (let i = 0; i < 30; i++) {
        const tree = new THREE.Group();

        // Trunk
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3, 0.4, 3, 8),
          new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        trunk.position.y = 1.5;
        trunk.castShadow = true;
        tree.add(trunk);

        // Leaves
        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(1.5, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        leaves.position.y = 3.5;
        leaves.castShadow = true;
        tree.add(leaves);

        tree.position.set(
          Math.random() * 80 - 40,
          0,
          Math.random() * 80 - 40
        );

        scene.add(tree);
      }
    }

    // ===== CHARACTER PREVIEWS =====
    async function loadCharacterPreviews() {
      const characters = ['soldier', 'robot', 'ninja', 'wizard', 'knight', 'archer'];

      for (const char of characters) {
        const canvas = document.querySelector(`.character-preview[data-character="${char}"]`);
        if (!canvas) continue;

        // Get actual canvas size
        const rect = canvas.getBoundingClientRect();
        const size = Math.min(rect.width, 200);

        const previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x1a1a2e);

        const previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        previewCamera.position.set(0, 2, 5);
        previewCamera.lookAt(0, 0, 0);

        const previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        previewRenderer.setSize(size, size);
        previewRenderer.setPixelRatio(window.devicePixelRatio);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 5, 5);
        previewScene.add(directionalLight);

        const model = await createCharacter(char);
        model.position.set(0, -1, 0);
        model.rotation.y = Math.PI; // Rotate 180 degrees to face forward
        previewScene.add(model);

        function animatePreview() {
          model.rotation.y += 0.01;
          previewRenderer.render(previewScene, previewCamera);
          requestAnimationFrame(animatePreview);
        }
        animatePreview();
      }
    }

    // ===== CHARACTER CREATION =====
    async function createCharacter(characterType) {
      const config = CHARACTER_CONFIG[characterType];
      if (!config) return createFallbackCharacter(characterType);

      if (loadedModels.has(characterType)) {
        const clone = loadedModels.get(characterType).clone();
        clone.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        return clone;
      }

      return new Promise((resolve) => {
        gltfLoader.load(
          config.model,
          (gltf) => {
            const model = gltf.scene;
            model.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            model.scale.set(1.5, 1.5, 1.5);
            loadedModels.set(characterType, model.clone());
            resolve(model);
          },
          null,
          () => resolve(createFallbackCharacter(characterType))
        );
      });
    }

    // Fallback character (simple geometry) if GLTF fails
    function createFallbackCharacter(characterType) {
      const group = new THREE.Group();
      const config = CHARACTER_CONFIG[characterType] || {};
      const color = config.color || 0xff0000;

      // Simple cylinder body
      const body = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
        new THREE.MeshStandardMaterial({ color })
      );
      body.position.y = 0.75;
      body.castShadow = true;
      group.add(body);

      // Head
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 16, 16),
        new THREE.MeshStandardMaterial({ color })
      );
      head.position.y = 1.8;
      head.castShadow = true;
      group.add(head);

      return group;
    }

    // ===== BACKEND CONNECTION =====
    async function connectToBackend() {
      try {
        const response = await sendToExtension('GAME_INIT');
        if (response.success) connected = true;
      } catch (error) {
        console.error('[Game] Connection error:', error);
      }
    }

    // ===== CHARACTER SELECTION =====
    async function selectCharacter(character) {
      selectedCharacter = character;
      isCharacterSelected = true;

      // Hide selection screen
      document.getElementById('character-selection').style.display = 'none';

      // Create player visual (AWAIT the GLTF load)
      myPlayer = await createCharacter(character);
      myPlayer.position.set(0, 1, 0);
      myPlayer.rotation.y = 0; // Face default forward direction
      scene.add(myPlayer);

      // Set character-specific health
      const config = CHARACTER_CONFIG[character];
      myHealth = config.health;
      updateHealthDisplay();

      // Create player physics body (cylinder shape for better collision)
      const playerShape = new CANNON.Cylinder(0.5, 0.5, 2, 8); // radius, radius, height, segments
      myPlayerBody = new CANNON.Body({
        mass: 5, // Give it mass so it can be hit
        position: new CANNON.Vec3(0, 1, 0),
        shape: playerShape,
        linearDamping: 0.9, // Add damping for smoother movement
        angularDamping: 0.9
      });
      myPlayerBody.fixedRotation = true; // Don't let physics rotate the player
      myPlayerBody.updateMassProperties();
      world.addBody(myPlayerBody);

      console.log('[Game] Player physics body created');
      console.log('[Game] Mouse controls enabled - move mouse to aim');

      // Notify backend via extension
      try {
        await sendToExtension('GAME_SELECT_CHARACTER', { character });
        console.log('[Game] Selected:', character);

        // Send player name to backend if set
        if (playerName) {
          await sendToExtension('GAME_SET_PLAYER_NAME', { playerName });
          console.log('[Game] Sent player name to backend:', playerName);
        }

        // Update character name in HUD
        document.getElementById('character-name').textContent = `${playerName || character.toUpperCase()}`;
      } catch (error) {
        console.error('[Game] Failed to select character:', error);
      }
    }

    // ===== GAME STATE =====
    function updateGameState(state) {
      // Update all other players (myPlayer is already created when character selected)
      if (state.players && Array.isArray(state.players)) {
        state.players.forEach(p => {
          // CRITICAL: Skip ourselves!
          if (p.id === mySocketId) {
            console.log('[Game] Skipping self in gameState:', p.id);
            return;
          }

          if (!players.has(p.id)) {
            addPlayer(p.id, p.character);
          }
          updatePlayerPosition(p.id, p.position, p.rotation);
        });
      }

      updatePlayerList();
    }

    async function addPlayer(id, character, playerName = null) {
      // CRITICAL: Don't add ourselves as another player!
      if (id === mySocketId) {
        console.log('[Game] Skipping addPlayer for self:', id);
        return;
      }

      if (players.has(id)) {
        console.log('[Game] Player already exists:', id);
        return;
      }

      console.log('[Game] Adding player:', id, character, playerName);

      // Load the character model (AWAIT)
      const player = await createCharacter(character);
      scene.add(player);

      // Create floating name label above player's head
      const nameLabel = createNameLabel(playerName || character);
      nameLabel.position.set(0, 3, 0); // Above the player
      player.add(nameLabel); // Attach to player so it follows

      // OTHER PLAYERS ARE VISUAL ONLY - NO PHYSICS BODY!
      // Only your own player has physics. Other players sync directly from network.
      players.set(id, {
        model: player,
        nameLabel: nameLabel,
        character: character,
        playerName: playerName,
        targetPosition: { x: 0, y: 1, z: 0 },
        targetRotation: { x: 0, y: 0, z: 0 }
      });

      updatePlayerCount();
    }

    // Create floating name label (THREE.js Sprite with text)
    function createNameLabel(name) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;

      // Background
      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Text
      context.font = 'Bold 28px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(name, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(2, 0.5, 1);

      return sprite;
    }

    function removePlayer(id) {
      const player = players.get(id);
      if (player) {
        scene.remove(player.model);

        // Clean up physics body if it exists (shouldn't for other players, but just in case)
        if (player.body) {
          world.removeBody(player.body);
        }

        players.delete(id);
        console.log('[Game] Removed player:', id);

        updatePlayerCount();
      }
    }

    function updatePlayerPosition(id, pos, rot) {
      const player = players.get(id);
      if (!player) return;

      // Set target position for smooth interpolation
      player.targetPosition = { x: pos.x, y: pos.y, z: pos.z };
      if (rot) {
        player.targetRotation = { x: rot.x, y: rot.y, z: rot.z };
      }
    }

    // Interpolate other players' positions for smooth movement
    function interpolatePlayers() {
      // SHOOTING GAME = NEED ACCURACY! High lerp factor for near-instant updates
      const lerpFactor = 0.85; // 0.85 = very fast, accurate position sync

      players.forEach((player, id) => {
        // Smoothly move toward target position
        player.model.position.x += (player.targetPosition.x - player.model.position.x) * lerpFactor;
        player.model.position.y += (player.targetPosition.y - player.model.position.y) * lerpFactor;
        player.model.position.z += (player.targetPosition.z - player.model.position.z) * lerpFactor;

        // Smoothly rotate toward target
        player.model.rotation.x += (player.targetRotation.x - player.model.rotation.x) * lerpFactor;
        player.model.rotation.y += (player.targetRotation.y - player.model.rotation.y) * lerpFactor;
        player.model.rotation.z += (player.targetRotation.z - player.model.rotation.z) * lerpFactor;
      });
    }

    function updatePlayerList() {
      const list = document.getElementById('players');
      list.innerHTML = '';
      players.forEach((data, id) => {
        const div = document.createElement('div');
        div.className = 'player-item';
        div.textContent = data.playerName || data.character;
        list.appendChild(div);
      });
    }

    function updatePlayerCount() {
      const totalPlayers = players.size + 1; // +1 for yourself
      const countEl = document.getElementById('player-count');
      if (countEl) {
        countEl.textContent = `Players Online: ${totalPlayers}`;
      }
      console.log('[Game] Player count updated:', totalPlayers);
    }

    // ===== MOVEMENT =====
    function updateMovement() {
      if (!myPlayerBody || !isCharacterSelected) return;

      // Get character-specific movement speed
      const config = CHARACTER_CONFIG[selectedCharacter];
      const charMoveSpeed = config ? config.moveSpeed : 0.15;
      const moveForce = charMoveSpeed * 100; // Convert to velocity

      // Get camera direction vectors for FPS-style movement
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();

      // Get camera's forward direction (project onto XZ plane for horizontal movement)
      camera.getWorldDirection(forward);
      forward.y = 0; // Keep movement horizontal
      forward.normalize();

      // Get camera's right direction (cross product of up and forward)
      right.crossVectors(camera.up, forward).normalize();

      // Calculate movement vector based on WASD and camera direction
      const moveDirection = new THREE.Vector3(0, 0, 0);

      // W/S - Move forward/backward relative to camera
      if (keys['w'] || keys['W']) {
        moveDirection.add(forward);
      }
      if (keys['s'] || keys['S']) {
        moveDirection.sub(forward);
      }

      // A/D - Strafe left/right relative to camera
      if (keys['a'] || keys['A']) {
        moveDirection.add(right);
      }
      if (keys['d'] || keys['D']) {
        moveDirection.sub(right);
      }

      // Normalize and apply speed
      if (moveDirection.length() > 0) {
        moveDirection.normalize();
        myPlayerBody.velocity.x = moveDirection.x * moveForce;
        myPlayerBody.velocity.z = moveDirection.z * moveForce;

        // Rotate player model to face movement direction
        const angle = Math.atan2(moveDirection.x, moveDirection.z);
        myPlayer.rotation.y = angle; // Face the direction of movement
      } else {
        // No movement - stop horizontal velocity
        myPlayerBody.velocity.x = 0;
        myPlayerBody.velocity.z = 0;
      }

      // Jump
      if (keys[' '] && Math.abs(myPlayerBody.velocity.y) < 0.1) {
        myPlayerBody.velocity.y = 8; // Jump impulse
      }

      // BOUNDARY COLLISION - Keep player inside arena
      const boundary = 48;
      if (myPlayerBody.position.x > boundary) myPlayerBody.position.x = boundary;
      if (myPlayerBody.position.x < -boundary) myPlayerBody.position.x = -boundary;
      if (myPlayerBody.position.z > boundary) myPlayerBody.position.z = boundary;
      if (myPlayerBody.position.z < -boundary) myPlayerBody.position.z = -boundary;

      // Check if grounded
      isGrounded = Math.abs(myPlayerBody.velocity.y) < 0.1 && myPlayerBody.position.y <= 1.1;

      // Send to backend - THROTTLED for performance (only every 50ms)
      const now = Date.now();
      if (connected && (now - lastNetworkUpdate) >= NETWORK_UPDATE_INTERVAL) {
        // Check if position changed significantly (at least 0.01 units)
        const dx = Math.abs(myPlayerBody.position.x - lastPositionSent.x);
        const dy = Math.abs(myPlayerBody.position.y - lastPositionSent.y);
        const dz = Math.abs(myPlayerBody.position.z - lastPositionSent.z);

        if (dx > 0.01 || dy > 0.01 || dz > 0.01) {
          lastNetworkUpdate = now;
          lastPositionSent = {
            x: myPlayerBody.position.x,
            y: myPlayerBody.position.y,
            z: myPlayerBody.position.z
          };

          sendToExtension('GAME_PLAYER_MOVE', {
            position: lastPositionSent,
            rotation: { x: myPlayer.rotation.x, y: myPlayer.rotation.y, z: myPlayer.rotation.z }
          }).catch(() => {}); // Ignore errors for movement updates
        }
      }

      // Camera follow - FPS style, position camera behind player based on yaw/pitch
      if (myPlayer) {
        // Calculate camera position based on yaw and pitch
        const offsetX = Math.sin(cameraYaw) * Math.cos(cameraPitch) * cameraDistance;
        const offsetY = Math.sin(cameraPitch) * cameraDistance + cameraHeight;
        const offsetZ = Math.cos(cameraYaw) * Math.cos(cameraPitch) * cameraDistance;

        // Position camera behind player
        camera.position.set(
          myPlayer.position.x + offsetX,
          myPlayer.position.y + offsetY,
          myPlayer.position.z + offsetZ
        );

        // Look at point in front of player based on camera direction
        const lookAtDistance = 10;
        const lookAtX = myPlayer.position.x - Math.sin(cameraYaw) * Math.cos(cameraPitch) * lookAtDistance;
        const lookAtY = myPlayer.position.y - Math.sin(cameraPitch) * lookAtDistance + cameraHeight;
        const lookAtZ = myPlayer.position.z - Math.cos(cameraYaw) * Math.cos(cameraPitch) * lookAtDistance;

        camera.lookAt(lookAtX, lookAtY, lookAtZ);
      }
    }

    // ===== SHOOTING =====
    function shoot() {
      if (!myPlayer || !isCharacterSelected || !connected) return;

      // Apply character-specific fire rate cooldown
      const config = CHARACTER_CONFIG[selectedCharacter];
      const fireRate = config ? config.fireRate : 600;
      const now = Date.now();

      if (now - lastShotTime < fireRate) {
        // Too soon to shoot again!
        return;
      }

      lastShotTime = now;

      // FPS-style shooting: Shoot where camera is looking
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0; // Keep shot horizontal
      direction.normalize();

      sendToExtension('GAME_PLAYER_SHOOT', {
        position: { x: myPlayer.position.x, y: myPlayer.position.y + 1.5, z: myPlayer.position.z },
        direction: { x: direction.x, y: 0, z: direction.z }, // y=0 for straight horizontal shot
        character: selectedCharacter // Send character for damage calculation
      }).catch((error) => {
        console.error('[Game] Failed to shoot:', error);
      });
    }

    function createBullet(data) {
      // Get character-specific bullet speed
      const shooterConfig = CHARACTER_CONFIG[data.character];
      const bulletSpeed = shooterConfig ? shooterConfig.bulletSpeed : 20;
      const bulletDamage = shooterConfig ? shooterConfig.damage : 10;

      // Create visual bullet
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00 })
      );
      bullet.position.set(data.position.x, data.position.y, data.position.z);

      // Create physics body for bullet
      const bulletShape = new CANNON.Sphere(0.15);
      const bulletBody = new CANNON.Body({
        mass: 0.1, // Light projectile
        shape: bulletShape,
        position: new CANNON.Vec3(data.position.x, data.position.y, data.position.z),
        velocity: new CANNON.Vec3(
          data.direction.x * bulletSpeed, // Character-specific bullet speed
          data.direction.y * bulletSpeed,
          data.direction.z * bulletSpeed
        ),
        collisionFilterGroup: 1,
        collisionFilterMask: -1
      });

      // Set up collision detection for this bullet
      bulletBody.addEventListener('collide', (event) => {
        const hitBody = event.body;

        // Check if bullet hit my player
        if (hitBody === myPlayerBody && data.ownerId !== 'me') {
          myHealth -= bulletDamage; // Character-specific damage
          updateHealthDisplay();
          console.log('[Game] Hit! Damage:', bulletDamage, 'Health:', myHealth);

          // Remove bullet
          world.removeBody(bulletBody);
          scene.remove(bullet);
          const bulletIndex = bullets.findIndex(b => b.userData.body === bulletBody);
          if (bulletIndex !== -1) bullets.splice(bulletIndex, 1);

          // Check if dead
          if (myHealth <= 0) {
            handlePlayerDeath();
          }
          return;
        }

        // Check if bullet hit a BLOCK
        blocks.forEach((blockData, blockId) => {
          if (hitBody === blockData.body) {
            console.log('[Game] Bullet hit block:', blockId);

            // Damage the block
            blockData.mesh.userData.health -= 1;
            const health = blockData.mesh.userData.health;

            // Visual feedback - change color based on health
            const healthPercent = health / blockData.mesh.userData.maxHealth;
            if (healthPercent <= 0.25) {
              blockData.mesh.material.color.setHex(0x330000); // Very dark red
            } else if (healthPercent <= 0.5) {
              blockData.mesh.material.color.setHex(0x663300); // Dark brown
            } else if (healthPercent <= 0.75) {
              blockData.mesh.material.color.setHex(0x7a4f2f); // Damaged brown
            }

            // Destroy block if health reaches 0
            if (health <= 0) {
              console.log('[Game] Block destroyed by bullet:', blockId);
              destroyBlock(blockId);

              // Notify backend to sync block destruction
              sendToExtension('GAME_DESTROY_BLOCK', { id: blockId }).catch(() => {});
            }

            // Remove bullet
            world.removeBody(bulletBody);
            scene.remove(bullet);
            const bulletIndex = bullets.findIndex(b => b.userData.body === bulletBody);
            if (bulletIndex !== -1) bullets.splice(bulletIndex, 1);
            return;
          }
        });

        // Check if hit other players
        players.forEach((playerData, id) => {
          if (playerData.body && hitBody === playerData.body && data.ownerId !== id) {
            console.log('[Game] Bullet hit player:', id);
            // Other player hit - backend handles their health
          }
        });
      });

      world.addBody(bulletBody);

      bullet.userData = {
        dir: data.direction,
        speed: 0.5,
        id: data.id,
        ownerId: data.ownerId || null,
        body: bulletBody // Link physics body
      };

      scene.add(bullet);
      bullets.push(bullet);
    }

    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bulletBody = bullet.userData.body;

        // Sync visual bullet with physics body
        if (bulletBody && bulletBody.world) {
          bullet.position.copy(bulletBody.position);
          bullet.quaternion.copy(bulletBody.quaternion);
        }

        // Remove bullet if out of bounds or physics body was removed
        if (!bulletBody || !bulletBody.world || bullet.position.length() > 100) {
          if (bulletBody && bulletBody.world) {
            world.removeBody(bulletBody);
          }
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }
    }

    function updateHealthDisplay() {
      const healthEl = document.getElementById('health');
      healthEl.textContent = `HP: ${myHealth}`;

      // Color based on health
      if (myHealth > 70) {
        healthEl.style.color = '#00ff00'; // Green
      } else if (myHealth > 30) {
        healthEl.style.color = '#ffaa00'; // Orange
      } else {
        healthEl.style.color = '#ff0000'; // Red
      }
    }

    function handlePlayerDeath() {
      console.log('[Game] You died! Respawning...');

      // Increment death count
      playerStats.deaths += 1;

      // Show death screen with stats
      alert(`ðŸ’€ YOU DIED! ðŸ’€\n\nKills: ${playerStats.kills}\nDeaths: ${playerStats.deaths}\nScore: ${playerStats.score}\nK/D Ratio: ${(playerStats.kills / Math.max(1, playerStats.deaths)).toFixed(2)}\n\nRespawning...`);

      // Reset health
      myHealth = 100;
      updateHealthDisplay();

      // Respawn at random position
      const respawnX = Math.random() * 40 - 20;
      const respawnZ = Math.random() * 40 - 20;

      if (myPlayer) {
        myPlayer.position.set(respawnX, 1, respawnZ);
      }

      if (myPlayerBody) {
        myPlayerBody.position.set(respawnX, 1, respawnZ);
        myPlayerBody.velocity.set(0, 0, 0); // Stop all movement
      }
    }

    // ===== BUILDING =====
    function placeBlock(data) {
      if (blocks.has(data.id)) return;

      // Create visual block
      const block = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshStandardMaterial({ color: 0x8b4513 })
      );
      block.position.set(data.position.x, data.position.y, data.position.z);
      block.castShadow = true;
      block.receiveShadow = true;

      // CREATE PHYSICS BODY FOR BLOCK (so players can jump on it!)
      const blockShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)); // Half-extents
      const blockBody = new CANNON.Body({
        mass: 0, // Static block (doesn't fall)
        shape: blockShape,
        position: new CANNON.Vec3(data.position.x, data.position.y, data.position.z)
      });
      world.addBody(blockBody);

      block.userData = {
        health: 4, // Takes 4 hits to destroy
        maxHealth: 4,
        id: data.id,
        body: blockBody // Store physics body reference
      };

      scene.add(block);
      blocks.set(data.id, { mesh: block, body: blockBody });

      console.log('[Game] Block placed at:', data.position);
    }

    function destroyBlock(id) {
      const blockData = blocks.get(id);
      if (blockData) {
        // Remove visual mesh
        scene.remove(blockData.mesh);

        // Remove physics body
        if (blockData.body) {
          world.removeBody(blockData.body);
        }

        blocks.delete(id);
        console.log('[Game] Block destroyed:', id);
      }
    }

    // ===== CONTROLS =====
    function setupControls() {
      window.addEventListener('keydown', (e) => {
        keys[e.key] = true;

        // E key to place block in front of player
        if ((e.key === 'e' || e.key === 'E') && isCharacterSelected && myPlayer && connected) {
          const placeDistance = 2;
          const placeX = Math.round(myPlayer.position.x);
          const placeY = Math.round(myPlayer.position.y); // Same height as player
          const placeZ = Math.round(myPlayer.position.z - placeDistance); // In front of player

          sendToExtension('GAME_PLACE_BLOCK', {
            position: { x: placeX, y: placeY, z: placeZ },
            type: 'grass'
          }).catch((error) => {
            console.error('[Game] Failed to place block:', error);
          });
        }
      });

      window.addEventListener('keyup', (e) => { keys[e.key] = false; });

      // Left click to shoot
      window.addEventListener('click', (e) => {
        if (isCharacterSelected) {
          shoot();
        }
      });
    }

    // ===== ANIMATION =====
    const timeStep = 1 / 60; // 60 FPS physics
    function animate() {
      requestAnimationFrame(animate);

      // Step physics world
      if (world) {
        world.step(timeStep);

        // Sync my player visual with physics body
        if (myPlayer && myPlayerBody) {
          myPlayer.position.copy(myPlayerBody.position);
          myPlayer.quaternion.copy(myPlayerBody.quaternion);
        }

        // Sync other players' visuals with physics bodies
        players.forEach((playerData) => {
          if (playerData.body) {
            playerData.model.position.copy(playerData.body.position);
          }
        });
      }

      updateMovement();
      interpolatePlayers(); // Smooth other players' movement
      updateBullets();

      renderer.render(scene, camera);
    }

    // ===== RESIZE =====
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ===== START =====
    init();
  </script>
</body>
</html>
